<!DOCTYPE html>
<html>
   <head>
      <title>Single Line Editor</title>
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11.4.0/dist/sweetalert2.min.css">
      <style>
         :root {
             --primary: #0078d4;
             --primary-dark: #005a9e;
             --bg-dark: #1e1e1e;
             --bg-darker: #161616;
             --surface: #252526;
             --surface-hover: #2d2d2d;
             --text: #ffffff;
             --button-icon-size: 18px;
         }
         body {
             background: var(--bg-dark);
             color: var(--text);
             font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
             margin: 0;
             padding: 20px;
             min-height: 100vh;
         }
         .swal2-popup {
             background: rgba(50, 50, 50, 0.95) !important;
             backdrop-filter: blur(10px) !important;
             border: 1px solid rgba(255, 255, 255, 0.1) !important;
             border-radius: 12px !important;
             color: #ffffff !important;
         }
         .swal2-title {
             color: #ffffff !important;
             font-size: 18px !important;
             font-weight: 500 !important;
         }
         .swal2-input {
             background: rgba(255, 255, 255, 0.1) !important;
             border: 1px solid rgba(255, 255, 255, 0.2) !important;
             color: #ffffff !important;
             border-radius: 8px !important;
             padding: 12px !important;
             margin-top: 20px !important;
         }
         .swal2-input:focus {
             border-color: var(--primary) !important;
             box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.3) !important;
         }
         .swal2-confirm {
             background: var(--primary) !important;
             border-radius: 8px !important;
             padding: 12px 24px !important;
         }
         .swal2-cancel {
             background: rgba(255, 255, 255, 0.1) !important;
             border-radius: 8px !important;
             padding: 12px 24px !important;
         }
         .swal2-actions {
             margin-top: 25px !important;
         }
         .container {
             position: relative;
             width: 800px;
             height: 800px;
             margin: 20px auto;
             border-radius: 12px;
             overflow: hidden;
             box-shadow: 0 8px 32px rgba(0,0,0,0.3);
             border: 1px solid rgba(255,255,255,0.1);
             transition: transform 0.3s ease, box-shadow 0.3s ease;
         }
         .container:hover {
             transform: translateY(-2px);
             box-shadow: 0 12px 48px rgba(0,0,0,0.4);
         }
         canvas {
             background: transparent; /* Changed from var(--bg-darker) to transparent */
             position: absolute;
             top: 0;
             left: 0;
             width: 800px;
             height: 800px;
             transition: filter 0.3s ease;
             z-index: 2; /* Ensures canvas is above imageLayer by default */
         }
         canvas:hover {
             filter: brightness(1.1);
         }
         #imageLayer {
             position: absolute;
             top: 0;
             left: 0;
             max-width: 100%;
             max-height: 100%;
             width: auto;
             height: auto;
             opacity: 0.5;
             pointer-events: none;
             z-index: 1; /* Ensures imageLayer is below canvas by default */
             transition: transform 0.3s ease, z-index 0.3s ease;
         }

         #imageLayer.interactive {
             pointer-events: all;
             cursor: move;
             z-index: 3; /* Moves imageLayer above canvas when interactive */
         }

         .controls {
             margin: 15px auto;
             text-align: center;
             background: var(--surface);
             padding: 20px;
             border-radius: 12px;
             box-shadow: 0 4px 16px rgba(0,0,0,0.2);
             max-width: 800px;
             border: 1px solid rgba(255,255,255,0.05);
             backdrop-filter: blur(12px);
         }
         .radio-group {
             display: inline-flex;
             background: rgba(0,0,0,0.2);
             border-radius: 8px;
             padding: 4px;
             margin: 0 10px;
             border: 1px solid rgba(255,255,255,0.1);
         }
         input[type="radio"] {
             display: none;
         }
         input[type="radio"] + label {
             padding: 8px 16px;
             cursor: pointer;
             border-radius: 6px;
             transition: all 0.3s ease;
             font-weight: 500;
             position: relative;
             overflow: hidden;
             display: flex;
             align-items: center;
             gap: 8px;
         }
         input[type="radio"] + label:hover {
             background: rgba(255,255,255,0.1);
         }
         input[type="radio"]:checked + label {
             background: var(--primary);
             color: white;
             box-shadow: 0 2px 8px rgba(0,120,212,0.4);
         }
         input[type="radio"]:checked + label:before {
             content: '';
             position: absolute;
             top: 0;
             left: 0;
             right: 0;
             bottom: 0;
             background: radial-gradient(circle at center, rgba(255,255,255,0.2) 0%, transparent 70%);
             animation: glow 2s infinite;
         }
         @keyframes glow {
             0%, 100% { opacity: 0.5; }
             50% { opacity: 1; }
         }
         .slider-container {
             display: flex;
             align-items: center;
             justify-content: center;
             margin: 20px 0;
             background: rgba(0,0,0,0.2);
             padding: 16px;
             border-radius: 8px;
             border: 1px solid rgba(255,255,255,0.1);
             /* Changed from flex-wrap: wrap to nowrap to keep elements on the same line */
             flex-wrap: nowrap;
             gap: 10px;
         }
         .slider-container label {
             margin-right: 10px;
             min-width: 120px;
             text-align: right;
             flex-shrink: 0; /* Prevents the label from shrinking */
         }
         input[type="range"] {
             width: 200px; /* Adjusted width to accommodate all elements */
             height: 6px;
             -webkit-appearance: none;
             background: rgba(255,255,255,0.1);
             border-radius: 3px;
             margin: 0 10px;
             transition: background 0.3s ease;
         }
         input[type="range"]:hover {
             background: rgba(255,255,255,0.2);
         }
         input[type="range"]::-webkit-slider-thumb {
             -webkit-appearance: none;
             width: 18px;
             height: 18px;
             background: var(--primary);
             border-radius: 50%;
             cursor: pointer;
             box-shadow: 0 2px 8px rgba(0,0,0,0.3);
             transition: transform 0.3s ease, box-shadow 0.3s ease;
         }
         input[type="range"]::-webkit-slider-thumb:hover {
             transform: scale(1.2);
             box-shadow: 0 4px 12px rgba(0,120,212,0.5);
         }
         .number-input {
             width: 100px; /* Increased width */
             padding: 12px; /* Increased padding */
             border: 1px solid rgba(255,255,255,0.2);
             border-radius: 6px;
             background: rgba(255,255,255,0.1);
             color: #ffffff;
             text-align: center;
             font-size: 24px; /* Increased font size */
             transition: border-color 0.3s ease, box-shadow 0.3s ease;
             flex-shrink: 0; /* Prevents the input from shrinking */
         }
         .number-input:focus {
             border-color: var(--primary);
             box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.3);
             outline: none;
         }
         button {
             background: var(--primary);
             color: white;
             border: none;
             padding: 10px 20px;
             border-radius: 8px;
             cursor: pointer;
             font-size: 14px;
             font-weight: 500;
             transition: all 0.3s ease;
             position: relative;
             overflow: hidden;
             box-shadow: 0 4px 12px rgba(0,0,0,0.2);
             display: inline-flex;
             align-items: center;
             gap: 8px;
             flex-shrink: 0; /* Prevents the button from shrinking */
         }
         button:hover {
             background: var(--primary-dark);
             transform: translateY(-2px);
             box-shadow: 0 6px 16px rgba(0,0,0,0.3);
         }
         button:active {
             transform: translateY(0);
         }
         button:before {
             content: '';
             position: absolute;
             top: 0;
             left: 0;
             right: 0;
             bottom: 0;
             background: linear-gradient(45deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
             transform: translateX(-100%);
             transition: transform 0.6s ease;
         }
         button:hover:before {
             transform: translateX(100%);
         }
         button.secondary {
             background: rgba(255,255,255,0.1);
             color: #ffffff;
         }
         button.secondary:hover {
             background: rgba(255,255,255,0.15);
         }
         .button-icon {
             font-size: var(--button-icon-size);
         }

         /* Responsive Adjustments */
         @media (max-width: 850px) {
             .container {
                 width: 100%;
                 height: auto;
             }
             canvas {
                 width: 100%;
                 height: auto;
             }
             .slider-container {
                 flex-direction: column;
                 align-items: flex-start;
             }
             .slider-container label,
             .slider-container input,
             .slider-container button {
                 width: 100%;
                 margin: 5px 0;
             }
             input[type="range"] {
                 width: 100%;
                 margin: 10px 0;
             }
             button {
                 width: 100%;
             }
             .number-input {
                 width: 100%;
                 font-size: 20px;
             }
             #incrementLevel {
                 padding: 12px;
                 font-size: 20px;
             }
         }

         /* Styles for Save Animation Canvas and Saved Icon */
         #saveAnimation {
             position: fixed;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             pointer-events: none;
             z-index: 9999;
         }

         #savedIcon {
             position: fixed;
             top: 20px;
             right: 20px;
             background: rgba(0, 0, 0, 0.7);
             color: #ffffff;
             padding: 10px 20px;
             border-radius: 30px;
             display: none;
             align-items: center;
             gap: 8px;
             box-shadow: 0 4px 12px rgba(0,0,0,0.3);
             opacity: 0;
             transform: scale(0.8);
         }

         /* Animation for Saved Icon */
         @keyframes fadeInOut {
             0% { opacity: 0; transform: scale(0.8); }
             10% { opacity: 1; transform: scale(1); }
             90% { opacity: 1; transform: scale(1); }
             100% { opacity: 0; transform: scale(0.8); }
         }

         /* Animation class */
         #savedIcon.animate {
             display: flex;
             animation: fadeInOut 2s forwards;
         }
      </style>
   </head>
   <body>
      <div class="controls">
          <div class="radio-group">
              <input type="radio" name="mode" id="dotMode" checked>
              <label for="dotMode"><span class="button-icon">üéü</span>Add Dots</label>
              <input type="radio" name="mode" id="edgeMode">
              <label for="edgeMode"><span class="button-icon">üéó</span>Add Edges</label>
          </div>
          <div class="slider-container">
              <label for="curvatureSlider">Edge Curvature:</label>
              <input type="range" id="curvatureSlider" min="-300" max="300" value="0" step="1"> <!-- Updated min and max -->
              <input type="number" id="curvatureInput" class="number-input" min="-300" max="300" value="0"> <!-- Updated min and max -->
              <button class="secondary" onclick="resetCurvature()"><span class="button-icon">üîÑ</span>Reset</button>
              <!-- Removed the tick marks and labels -->
          </div>
          <input type="file" id="imageInput" accept="image/*" style="display: none">
          <button onclick="document.getElementById('imageInput').click()"><span class="button-icon">üì§</span>Upload Image</button>
          <button onclick="toggleImageInteraction()" id="toggleBtn"><span class="button-icon">üéÅ</span>Enable Image Interaction</button>
      </div>
      <div class="container">
          <img id="imageLayer" style="display:none"> <!-- Moved above the canvas -->
          <canvas id="canvas"></canvas>
      </div>
      <div class="controls">
          <button id="saveButton" onclick="exportGraph()"><span class="button-icon">üíæ</span>Export</button>
      </div>

      <!-- Canvas cho hi·ªáu ·ª©ng √°nh s√°ng galaxy -->
      <canvas id="saveAnimation"></canvas>

      <!-- Icon th√¥ng b√°o l∆∞u th√†nh c√¥ng -->
      <div id="savedIcon"><span>‚úîÔ∏è Saved</span></div>

      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.4.0/dist/sweetalert2.all.min.js"></script>
      <script>
         // C√°c ƒëo·∫°n m√£ JavaScript hi·ªán t·∫°i c·ªßa b·∫°n...

         // Th√™m ƒëo·∫°n m√£ d∆∞·ªõi ƒë√¢y v√†o cu·ªëi th·∫ª <script>

         // L·ªõp Particle ƒë·ªÉ qu·∫£n l√Ω c√°c h·∫°t √°nh s√°ng
         class Particle {
             constructor(x, y, targetX, targetY) {
                 this.x = x;
                 this.y = y;
                 // T√≠nh to√°n vector h∆∞·ªõng t·ªõi ƒëi·ªÉm ƒë√≠ch
                 const dx = targetX - x;
                 const dy = targetY - y;
                 const distance = Math.sqrt(dx * dx + dy * dy);
                 const speed = distance / 60; // T·ªïng th·ªùi gian 60 frames
                 this.vx = dx / distance * speed;
                 this.vy = dy / distance * speed;
                 this.opacity = 1;
                 this.size = Math.random() * 3 + 2;
                 // M√†u s·∫Øc ng·∫´u nhi√™n v·ªõi t√¥ng m√†u xanh d∆∞∆°ng/t√≠m
                 const hue = Math.random() * 60 + 240; // 240-300 ƒë·ªô
                 this.color = `hsl(${hue}, 100%, 75%)`;
             }

             update() {
                 this.x += this.vx;
                 this.y += this.vy;
                 this.opacity -= 1 / 60;
             }

             draw(ctx) {
                 ctx.globalAlpha = this.opacity;
                 ctx.fillStyle = this.color;
                 ctx.beginPath();
                 ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                 ctx.fill();
             }

             isDead() {
                 return this.opacity <= 0;
             }
         }

         // H√†m ƒë·ªÉ hi·ªÉn th·ªã icon th√¥ng b√°o l∆∞u th√†nh c√¥ng
         function showSavedIcon() {
             const savedIcon = document.getElementById('savedIcon');
             savedIcon.classList.add('animate');

             // Lo·∫°i b·ªè l·ªõp 'animate' sau khi animation k·∫øt th√∫c ƒë·ªÉ c√≥ th·ªÉ k√≠ch ho·∫°t l·∫°i sau n√†y
             savedIcon.addEventListener('animationend', () => {
                 savedIcon.classList.remove('animate');
             }, { once: true });
         }

         // H√†m ƒë·ªÉ k√≠ch ho·∫°t hi·ªáu ·ª©ng √°nh s√°ng khi l∆∞u
         function triggerSaveAnimation() {
             const animationCanvas = document.getElementById('saveAnimation');
             const ctx = animationCanvas.getContext('2d');
             const particles = [];

             // Thi·∫øt l·∫≠p k√≠ch th∆∞·ªõc canvas
             function resizeCanvas() {
                 animationCanvas.width = window.innerWidth;
                 animationCanvas.height = window.innerHeight;
             }
             resizeCanvas();
             window.addEventListener('resize', resizeCanvas);

             // L·∫•y v·ªã tr√≠ n√∫t Save (Export)
             const saveButton = document.getElementById('saveButton');
             const rect = saveButton.getBoundingClientRect();
             const startX = rect.left + rect.width / 2;
             const startY = rect.top + rect.height / 2;

             // ƒê·ªãnh v·ªã ƒëi·ªÉm ƒë√≠ch ·ªü g√≥c tr√™n c√πng b√™n ph·∫£i (40px t·ª´ tr√™n v√† ph·∫£i)
             const targetX = window.innerWidth - 40;
             const targetY = 40;

             // T·∫°o nhi·ªÅu h·∫°t
             const numParticles = 20;
             for(let i=0; i<numParticles; i++) {
                 particles.push(new Particle(startX, startY, targetX, targetY));
             }

             // V√≤ng l·∫∑p animation
             function animate() {
                 ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
                 particles.forEach(p => {
                     p.update();
                     p.draw(ctx);
                 });

                 // Lo·∫°i b·ªè c√°c h·∫°t ƒë√£ bi·∫øn m·∫•t
                 for(let i = particles.length -1; i >=0; i--){
                     if(particles[i].isDead()) {
                         particles.splice(i, 1);
                     }
                 }

                 if(particles.length > 0) {
                     requestAnimationFrame(animate);
                 } else {
                     // Hi·ªÉn th·ªã icon th√¥ng b√°o l∆∞u th√†nh c√¥ng
                     showSavedIcon();
                     // X√≥a canvas sau khi ho√†n th√†nh
                     ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
                 }
             }

             animate();
         }

         // Ch·ªânh s·ª≠a h√†m exportGraph ƒë·ªÉ g·ªçi hi·ªáu ·ª©ng khi l∆∞u th√†nh c√¥ng
         function exportGraph() {
             const data = {
                 dots: dots.map(dot => ({ x: dot.x, y: dot.y })),
                 edges: edges.map(edge => {
                     const edgeData = {
                         startIndex: edge.start,
                         endIndex: edge.end
                     };
                     if (edge.curvature !== 0) {
                         const midX = (dots[edge.start].x + dots[edge.end].x) / 2;
                         const midY = (dots[edge.start].y + dots[edge.end].y) / 2;
                         const normal = {
                             x: -(dots[edge.end].y - dots[edge.start].y),
                             y: dots[edge.end].x - dots[edge.start].x
                         };
                         const len = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                         edgeData.controlPoint = {
                             x: midX + (normal.x / len) * edge.curvature,
                             y: midY + (normal.y / len) * edge.curvature
                         };
                     }
                     return edgeData;
                 })
             };

             const jsonString = JSON.stringify(data, null, 2);

             Swal.fire({
                 title: 'Save File',
                 html: `
                    <div style="text-align: center; margin-bottom: 10px;">Nh·∫≠p m·ªôt s·ªë l√† level ƒë·ªÉ ƒë·∫∑t t√™n file</div>
                    <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <input type="number" id="levelInput" class="number-input" min="1" step="1">
                        <button id="incrementLevel" class="increment-button">+</button>
                    </div>
                `,
                 showCancelButton: true,
                 confirmButtonText: 'Save',
                 cancelButtonText: 'Cancel',
                 focusConfirm: false, // To prevent auto focus on confirm button
                 didOpen: () => {
                     const levelInput = Swal.getPopup().querySelector('#levelInput');
                     const incrementButton = Swal.getPopup().querySelector('#incrementLevel');
                     
                     // Load cached level
                     const cachedLevel = localStorage.getItem('level') || '1';
                     levelInput.value = cachedLevel;
                     
                     // Add event listener to increment button
                     incrementButton.addEventListener('click', () => {
                         let currentVal = parseInt(levelInput.value) || 1;
                         currentVal += 1;
                         levelInput.value = currentVal;
                     });
                 },
                 preConfirm: () => {
                     const level = Swal.getPopup().querySelector('#levelInput').value;
                     if (!level) {
                         Swal.showValidationMessage('Vui l√≤ng nh·∫≠p m·ªôt s·ªë');
                         return false;
                     }
                     if (!Number.isInteger(Number(level)) || Number(level) < 1) {
                         Swal.showValidationMessage('Vui l√≤ng nh·∫≠p m·ªôt s·ªë nguy√™n d∆∞∆°ng h·ª£p l·ªá');
                         return false;
                     }
                     // Save level to localStorage
                     localStorage.setItem('level', level);
                     return level;
                 }
             }).then((result) => {
                 if (result.isConfirmed) {
                     const level = result.value;
                     const blob = new Blob([jsonString], { type: "application/json" });
                     const link = document.createElement("a");
                     link.href = URL.createObjectURL(blob);
                     link.download = `lv_${level}.json`; // Th√™m ti·ªÅn t·ªë 'lv_'
                     link.style.display = "none";
                     document.body.appendChild(link);
                     link.click();
                     document.body.removeChild(link);

                     // G·ªçi hi·ªáu ·ª©ng √°nh s√°ng khi l∆∞u th√†nh c√¥ng
                     triggerSaveAnimation();
                 }
             });
         }

         // C√°c ƒëo·∫°n m√£ JavaScript hi·ªán t·∫°i c·ªßa b·∫°n ti·∫øp t·ª•c...

         const canvas = document.getElementById('canvas');
         const ctx = canvas.getContext('2d');
         const dots = [];
         const edges = [];
         let selectedDot = null;
         let tempEdge = null;
         let isDragging = false;
         let selectedEdge = null;
         let imageInteractive = false;
         let isDraggingImage = false;
         let lastX = 0;
         let lastY = 0;
         let imageScale = 1;
         let imageX = 0;
         let imageY = 0;

         const imageLayer = document.getElementById('imageLayer');
         const imageInput = document.getElementById('imageInput');
         const toggleBtn = document.getElementById('toggleBtn');
         const container = document.querySelector('.container');
         const curvatureSlider = document.getElementById('curvatureSlider');
         const curvatureInput = document.getElementById('curvatureInput');
         const dotModeRadio = document.getElementById('dotMode');
         const edgeModeRadio = document.getElementById('edgeMode');

         // History stack for undo functionality
         const historyStack = [];
         const MAX_HISTORY = 20; // Optional: Limit the history stack size

         function saveState() {
             const dotsCopy = dots.map(dot => ({...dot}));
             const edgesCopy = edges.map(edge => ({...edge}));
             historyStack.push({dots: dotsCopy, edges: edgesCopy});
             if(historyStack.length > MAX_HISTORY) {
                 historyStack.shift(); // Remove the oldest state
             }
         }

         function undo() {
             if(historyStack.length === 0) {
                 Swal.fire('Nothing to undo', '', 'info');
                 return;
             }
             const lastState = historyStack.pop();
             // Restore dots
             dots.length = 0;
             lastState.dots.forEach(dot => dots.push(dot));
             // Restore edges
             edges.length = 0;
             lastState.edges.forEach(edge => edges.push(edge));
             draw();
         }

         // Center the image when it's loaded
         imageLayer.onload = function() {
             // Get container dimensions
             const containerRect = container.getBoundingClientRect();
             const containerWidth = containerRect.width;
             const containerHeight = containerRect.height;

             // Get image display dimensions
             const imageRect = imageLayer.getBoundingClientRect();
             const imageWidth = imageRect.width;
             const imageHeight = imageRect.height;

             // Calculate offsets to center the image
             imageX = (containerWidth - imageWidth) / 2;
             imageY = (containerHeight - imageHeight) / 2;

             updateImageTransform();
         };

         imageInput.addEventListener('change', function(e) {
             const file = e.target.files[0];
             if (file) {
                 const reader = new FileReader();
                 reader.onload = function(event) {
                     imageLayer.src = event.target.result;
                     imageLayer.style.display = 'block';
                     imageX = 0;
                     imageY = 0;
                     imageScale = 1;
                     updateImageTransform();
                 };
                 reader.readAsDataURL(file);
             }
         });

         function toggleImageInteraction() {
             imageInteractive = !imageInteractive;
             imageLayer.classList.toggle('interactive');
             toggleBtn.textContent = imageInteractive ? 'Disable Image Interaction' : 'Enable Image Interaction';
             toggleBtn.innerHTML = imageInteractive 
                 ? '<span class="button-icon">üîì</span>Disable Image Interaction' 
                 : '<span class="button-icon">üéÅ</span>Enable Image Interaction';

             if (imageInteractive) {
                 // Optionally disable canvas pointer events to prevent interference
                 canvas.style.pointerEvents = 'none';
             } else {
                 canvas.style.pointerEvents = 'auto';
             }
         }

         imageLayer.addEventListener('mousedown', function(e) {
             if (!imageInteractive) return;
             isDraggingImage = true;
             lastX = e.clientX;
             lastY = e.clientY;
         });

         document.addEventListener('mousemove', function(e) {
             if (!isDraggingImage) return;
             const deltaX = e.clientX - lastX;
             const deltaY = e.clientY - lastY;
             imageX += deltaX;
             imageY += deltaY;
             lastX = e.clientX;
             lastY = e.clientY;
             updateImageTransform();
         });

         document.addEventListener('mouseup', function() {
             isDraggingImage = false;
         });

         imageLayer.addEventListener('wheel', function(e) {
             if (!imageInteractive) return;
             e.preventDefault();
             const scala = e.deltaY > 0 ? 0.9 : 1.1;
             imageScale *= scala;
             imageScale = Math.max(0.1, Math.min(5, imageScale));
             updateImageTransform();
         }, { passive: false });

         function updateImageTransform() {
             imageLayer.style.transform = `translate(${imageX}px, ${imageY}px) scale(${imageScale})`;
         }
         const dpr = window.devicePixelRatio || 1;
         const rectCanvas = canvas.getBoundingClientRect();
         
         canvas.width = rectCanvas.width * dpr;
         canvas.height = rectCanvas.height * dpr;
         ctx.scale(dpr, dpr);
         
         const scale = 2;
         
         function drawGrid() {
             ctx.strokeStyle = '#363636';
             ctx.lineWidth = 0.5;
             
             for(let x = 0; x <= 400; x += 10) {
                 ctx.beginPath();
                 ctx.moveTo(x * scale, 0);
                 ctx.lineTo(x * scale, 800);
                 ctx.stroke();
             }
             
             for(let y = 0; y <= 400; y += 10) {
                 ctx.beginPath(); 
                 ctx.moveTo(0, y * scale);
                 ctx.lineTo(800, y * scale);
                 ctx.stroke();
             }
         
             ctx.strokeStyle = '#2d2d2d';
             ctx.lineWidth = 0.2;
             
             for(let x = 0; x <= 400; x += 2) {
                 ctx.beginPath();
                 ctx.moveTo(x * scale, 0);
                 ctx.lineTo(x * scale, 800);
                 ctx.stroke();
             }
             
             for(let y = 0; y <= 400; y += 2) {
                 ctx.beginPath();
                 ctx.moveTo(0, y * scale);
                 ctx.lineTo(800, y * scale);
                 ctx.stroke();
             }
             
             ctx.strokeStyle = '#0078d4';
             ctx.lineWidth = 2;
         }
         
         function resetCurvature() {
             curvatureSlider.value = 0;
             curvatureInput.value = 0;
             draw();
         }
         
         // Synchronize slider and input box
         curvatureSlider.addEventListener('input', function() {
             curvatureInput.value = curvatureSlider.value;
             draw();
         });

         curvatureInput.addEventListener('input', function() {
             let val = parseInt(curvatureInput.value);
             if (isNaN(val)) val = 0;
             val = Math.max(-300, Math.min(300, val)); // Updated range
             curvatureInput.value = val;
             curvatureSlider.value = val;
             draw();
         });
         
         canvas.addEventListener('mousedown', handleMouseDown);
         canvas.addEventListener('mousemove', handleMouseMove);
         canvas.addEventListener('mouseup', handleMouseUp);
         
         function handleMouseDown(e) {
             const rect = canvas.getBoundingClientRect();
             const x = ((e.clientX - rect.left) / scale) * (400/400);
             const y = ((e.clientY - rect.top) / scale) * (400/400);
             
             if(dotModeRadio.checked) {
                 if(x >= 0 && x <= 400 && y >= 0 && y <= 400) {
                     saveState(); // Save state before adding a dot
                     const roundedX = Math.round(x / 2) * 2;
                     const roundedY = Math.round(y / 2) * 2;
                     dots.push({x: roundedX, y: roundedY});
                 }
             } else {
                 selectedDot = findNearestDot(x, y);
                 if(selectedDot !== null) {
                     isDragging = true;
                 }
             }
             draw();
         }
         
         function handleMouseMove(e) {
             if(!isDragging) return;
             
             const rect = canvas.getBoundingClientRect();
             const x = ((e.clientX - rect.left) / scale) * (400/400);
             const y = ((e.clientY - rect.top) / scale) * (400/400);
             
             tempEdge = {
                 start: selectedDot,
                 end: {x, y},
                 curvature: parseInt(curvatureSlider.value)
             };
             
             draw();
         }
         
         function handleMouseUp(e) {
             if(!isDragging) return;
             
             const rect = canvas.getBoundingClientRect();
             const x = ((e.clientX - rect.left) / scale) * (400/400);
             const y = ((e.clientY - rect.top) / scale) * (400/400);
             
             const endDot = findNearestDot(x, y);
             if(endDot !== null && endDot !== selectedDot) {
                 saveState(); // Save state before adding an edge
                 edges.push({
                     start: selectedDot,
                     end: endDot,
                     curvature: parseInt(curvatureSlider.value)
                 });
             }
             
             isDragging = false;
             tempEdge = null;
             draw();
         }
         
         function findNearestDot(x, y) {
             for(let i = 0; i < dots.length; i++) {
                 const dx = dots[i].x - x;
                 const dy = dots[i].y - y;
                 if(Math.sqrt(dx*dx + dy*dy) < 10) {
                     return i;
                 }
             }
             return null;
         }
         
         function draw() {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             
             ctx.save();
             ctx.scale(scale, scale);
             
             drawGrid();
             
             ctx.shadowColor = 'rgba(0,120,212,0.4)';
             ctx.shadowBlur = 10;
             ctx.strokeStyle = '#0078d4';
             ctx.lineWidth = 2;
             edges.forEach(edge => drawEdge(edge));
             
             if(tempEdge) {
                 ctx.beginPath();
                 ctx.moveTo(dots[tempEdge.start].x, dots[tempEdge.start].y);
                 
                 if(tempEdge.curvature !== 0) {
                     const midX = (dots[tempEdge.start].x + tempEdge.end.x) / 2;
                     const midY = (dots[tempEdge.start].y + tempEdge.end.y) / 2;
                     const normal = {
                         x: -(tempEdge.end.y - dots[tempEdge.start].y),
                         y: tempEdge.end.x - dots[tempEdge.start].x
                     };
                     const len = Math.sqrt(normal.x*normal.x + normal.y*normal.y);
                     const controlPoint = {
                         x: midX + normal.x/len * tempEdge.curvature,
                         y: midY + normal.y/len * tempEdge.curvature
                     };
                     
                     ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, tempEdge.end.x, tempEdge.end.y);
                 } else {
                     ctx.lineTo(tempEdge.end.x, tempEdge.end.y);
                 }
                 
                 ctx.stroke();
             }
             
             ctx.shadowColor = 'rgba(0,120,212,0.6)';
             ctx.shadowBlur = 15;
             ctx.fillStyle = '#fff';
             ctx.strokeStyle = '#0078d4';
             ctx.lineWidth = 2;
             dots.forEach((dot, i) => {
                 ctx.beginPath();
                 ctx.arc(dot.x, dot.y, 5, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.stroke();
                 
                 ctx.shadowColor = 'transparent';
                 ctx.fillStyle = '#fff';
                 ctx.font = '12px sans-serif';
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText(i.toString(), dot.x, dot.y + 15);
             });
             
             ctx.restore();
         }
         
         function drawEdge(edge) {
             ctx.beginPath();
             ctx.moveTo(dots[edge.start].x, dots[edge.start].y);
             
             if(edge.curvature !== 0) {
                 const midX = (dots[edge.start].x + dots[edge.end].x) / 2;
                 const midY = (dots[edge.start].y + dots[edge.end].y) / 2;
                 const normal = {
                     x: -(dots[edge.end].y - dots[edge.start].y),
                     y: dots[edge.end].x - dots[edge.start].x
                 };
                 const len = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                 const controlPoint = {
                     x: midX + normal.x / len * edge.curvature,
                     y: midY + normal.y / len * edge.curvature
                 };
                 
                 ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, dots[edge.end].x, dots[edge.end].y);
             } else {
                 ctx.lineTo(dots[edge.end].x, dots[edge.end].y);
             }
             
             ctx.stroke();
         }
         
         // Change cursor based on selected mode
         function updateCursor() {
             if(dotModeRadio.checked) {
                 container.style.cursor = 'crosshair';
             } else if(edgeModeRadio.checked) {
                 container.style.cursor = 'pointer';
             } else {
                 container.style.cursor = 'default';
             }
         }

         // Add event listeners for radio buttons to update cursor
         dotModeRadio.addEventListener('change', updateCursor);
         edgeModeRadio.addEventListener('change', updateCursor);

         // Initialize cursor
         updateCursor();

         // Add keyboard listener for undo (Ctrl+Z)
         document.addEventListener('keydown', function(e) {
             if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                 e.preventDefault();
                 undo();
             }
         });

         draw();
      </script>
   </body>
</html>
